//
// Copyright (C) 2006-2011 Christoph Sommer <christoph.sommer@uibk.ac.at>
//
// Documentation for these modules is at http://veins.car2x.org/
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//

#include "veins/modules/application/traci/TraCIDemo11p.h"
#include <iostream>
#include <fstream>
#include <cmath>
#include <random>

using namespace std;

using Veins::TraCIMobilityAccess;
using Veins::AnnotationManagerAccess;

const simsignalwrap_t TraCIDemo11p::parkingStateChangedSignal = simsignalwrap_t(TRACI_SIGNAL_PARKING_CHANGE_NAME);

Define_Module(TraCIDemo11p);

void TraCIDemo11p::initialize(int stage) {
    BaseWaveApplLayer::initialize(stage);
    if (stage == 0) {
        mobility        = TraCIMobilityAccess().get(getParentModule());
        traci           = mobility->getCommandInterface();
        traciVehicle    = mobility->getVehicleCommandInterface();
        traciLane       = mobility->getLaneCommandInterface();
        annotations     = AnnotationManagerAccess().getIfExists();
        ASSERT(annotations);
        findHost()->subscribe(parkingStateChangedSignal, this);

        bpd = par("bpdis");
        traciVehicle->setSpeedMode(23);

        lane = stoi(traciVehicle->getLaneId());
        isEV = strcmp(traciVehicle->nodeId.c_str(),"vip") == 0;

        if(isEV){
            std::cout<<"Node["<<myId<<"] : isEV : lane = " << lane << endl;
            std::cout<<"Node["<<myId<<"] : bpd = " << bpd << endl;
        }
        changeLane = new cMessage("changeLane");
    }

}

void TraCIDemo11p::handleSelfMsg(cMessage *msg)
{
    switch(EVStrategyUsed){
        case EV_FIXED_LANE:
            handleSelfMsgFixedLane(msg);
            break;
        case EV_BEST_LANE:
            handleSelfMsgBestLane(msg);
            break;
    }
}

void TraCIDemo11p::onBeacon(WaveShortMessage* wsm) {
    switch(EVStrategyUsed){
        case EV_FIXED_LANE:
            handleBeaconFixedLane(wsm);
            break;
        case EV_BEST_LANE:
            handleBeaconBestLane(wsm);
            break;
    }
}

void TraCIDemo11p::handleSelfMsgFixedLane(cMessage *msg)
{
    if(msg == sendBeaconEvt && isEV){
        WaveShortMessage* wsm = prepareWSM("beacon", beaconLengthBits, type_CCH, beaconPriority, 0, -1);
        sendWSM(wsm);
    }else if(msg == changeLane){
        EV <<  "Change Lane called" << endl ;
        if(!dontChange){
            if(traciVehicle->getLaneIndex() == 0){
                traciVehicle->changeLane(1,50000);
                changed = true;
                lane = 1;
            }else if(traciVehicle->getLaneIndex() == 1){
                traciVehicle->changeLane(0,50000);
                changed = false;
                lane = 0;
            }
            std::cout<<"Node["<<myId<<"] : lane change : newLane = " << lane << endl;
        }else{
            scheduleChangeLane();
        }
    }
}

void TraCIDemo11p::handleSelfMsgBestLane(cMessage *msg)
{

}

void TraCIDemo11p::handleBeaconFixedLane(WaveShortMessage* wsm)
{
    bool isSenderSameLane   = wsm->getLane() == lane;
    bool isSenderAhead      = mobility->getPositionAt(simTime()).x < wsm->getSenderPos().x;
    bool isSenderEV         = wsm->getIsSenderEV();
    double distance2Sender  = abs(wsm->getSenderPos().x - mobility->getPositionAt(simTime()).x);

    if(isSenderEV && isSenderSameLane && !isSenderAhead && distance2Sender < bpd){
        scheduleChangeLane();
    }else if(isSenderEV && !isSenderSameLane && isSenderAhead){
        if(changed) scheduleChangeLane();
    }
}

void TraCIDemo11p::scheduleChangeLane(){
    if(!changeLane->isScheduled()){
//        std::cout<<"Node["<<myId<<"] : change scheduled" << endl;
        dontChange = false;
        WaveShortMessage* wsm = prepareWSM("want_change", beaconLengthBits, type_CCH, beaconPriority, 0, -1);
        isAffectedByEV = 1.0;
        sendWSM(wsm);
        scheduleAt(simTime() + 2, changeLane);
    }
}

void TraCIDemo11p::handleBeaconBestLane(WaveShortMessage* wsm)
{

}

void TraCIDemo11p::onDontChange(WaveShortMessage* wsm) {
    EV << "Dont change received \n";
    if(myId == wsm->getRecipientAddress()) dontChange = true;
}

void TraCIDemo11p::onWantChange(WaveShortMessage* wsm) {

    int senderID        = wsm->getSenderAddress();
    double senderSpeed  = wsm->getSpeed();
    double selfSpeed    = traciVehicle->getSpeed();
    double RPURegion    = selfSpeed * 2;
    double FPURegion    = senderSpeed * 2;
    bool isSenderSameLane   = mobility->getPositionAt(simTime()).y != wsm->getSenderPos().y;
    bool isSenderAhead      = mobility->getPositionAt(simTime()).x < wsm->getSenderPos().x;
    double distance2Sender  = abs(wsm->getSenderPos().x - mobility->getPositionAt(simTime()).x);
//    speed_margine = traciVehicle->getSpeed() - pow(traciVehicle->getSpeed()*traciVehicle->getSpeed() - 2*2.9*5.4 , 0.5);

    if(isSenderSameLane){
        if(distance2Sender < URegion) {
            sendDontChange(senderID);
            traciVehicle->slowDown(traciVehicle->getSpeed() * 0.7, 100);
//            traciVehicle->slowDown(senderSpeed,50);
        }
        else if(isSenderAhead){
            if(distance2Sender < RPURegion && senderSpeed < selfSpeed){
                sendDontChange(senderID);
                traciVehicle->slowDown(traciVehicle->getSpeed() * 0.7, 100);
//                traciVehicle->slowDown(senderSpeed,50);
            }
        }else{
            if(distance2Sender < FPURegion && senderSpeed > selfSpeed) sendDontChange(senderID);
            traciVehicle->slowDown(traciVehicle->getSpeed() * 1.3, 100);
//                traciVehicle->slowDown(senderSpeed,50);
        }
    }
}

void TraCIDemo11p::onData(WaveShortMessage* wsm) {

}

void TraCIDemo11p::sendDontChange(int recID){
//    std::cout<<"Node["<<myId<<"] : sending don't change to = "<< recID << endl;

    WaveShortMessage* wsm = prepareWSM("dont_change", beaconLengthBits, type_CCH, beaconPriority, recID, -1);
    sendWSM(wsm);
//    is_self_affected_by_ev = 1.0;

}

void TraCIDemo11p::sendWSM(WaveShortMessage* wsm) {
    wsm->setSenderPos(mobility->getPositionAt(simTime()));
    wsm->setSpeed(traciVehicle->getSpeed());
    wsm->setSenderAffectedByEV(isAffectedByEV);
    wsm->setIsSenderEV(isEV);
    wsm->setLane(lane);
    sendDelayedDown(wsm,individualOffset);
}

void TraCIDemo11p::finish(){

        recordScalar("is EV",isEV);
        recordScalar("bpd", bpd);
        recordScalar("isAffectedByEV", isAffectedByEV);

}
